package package1;

import java.util.*;
import java.util.LinkedList;

/*****************************************************
 * @author Gloire Rubambiza & Recod Rekodeo
 *@version 04/08/2015
 *Class that handles all list operations
 *Implements all methods of ISimpleDatabase interface
 *****************************************************/


public class SimpleDatabase implements ISimpleDatabase{
	/**Linkedlist of nodes */
	private package1.LinkedList link;

	/**The initial node that creates all other nodes */
	private Node node;



	/****************************************************
	 * Constructor for SimpleDatabase
	 * Objects from the class are to be used for testing
	 * @param plink reference to an existing LinkedList
	 * @param pnode a node in the existing LinkedList
	 ****************************************************/
	public SimpleDatabase(package1.LinkedList plink, Node pnode){
		link = plink; // Can be given an already-existing linkedlist as parameter
		node = pnode;
	}

	/****************************************************
	 * Constructor for SimpleDatabase
	 * Objects from the class are to be used for testing
	 * Instantiates a new LinkedList of nodes
	 ****************************************************/
	public SimpleDatabase(){
		link = new package1.LinkedList(); //Creates a new LinkedList
		node = new Node();
	}

	@Override
	/************************************************
	 * Method that inserts student info into a node
	 * Unless empty, add the record at the end
	 * @param student the student to be inserted
	 ***********************************************/
	public void insert(Student student){
		Node n = new Node(student);
		link.add(n);
	}


	@Override
	/************************************************************
	 * Method that deletes a student record from the linked list
	 * Uses a gNumber to find the node to be deleted
	 * @param gNumber the number to compare against
	 ************************************************************/
	public boolean delete(String gNumber) {
		if (link.getCount() == 0){
			return false;
		}
		Node temp = link.getHead();
		while(temp.getNext() != null){
			if(temp.getCurrentStudent().getGNumber().compareTo(gNumber) == 0){
				link.setHead(temp.getNext());
				temp.setNext(null);
				return true;
			}
			if (temp.getNext().getCurrentStudent().getGNumber().compareTo(gNumber) == 0){
				Node breaklink = temp.getNext(); 
				temp.setNext(temp.getNext().getNext()); //point temp to the second node down
				breaklink.setNext(null); //expose the node to garbage collector
				//break?;
			}
			temp = temp.getNext();
		}
		return true;
	}

	@Override
	/*******************************************************
	 * Method to find a unique student in the LinkedList
	 * Uses a gNumber to find the student
	 * @param gNumber the unique student identifying number
	 ******************************************************/
	public Student find(String gNumber) {
		Node temp = link.getHead();
		if(temp.getCurrentStudent().getGNumber().compareTo(gNumber)== 0){
			return temp.getCurrentStudent();
		}
		while(temp.getNext() != null){
			if(temp.getNext().getCurrentStudent().getGNumber().compareTo(gNumber)== 0){
				return temp.getNext().getCurrentStudent();
			}
			temp = temp.getNext();
		}
		return null;
	}

	@Override
	/*******************************************************
	 * Method to sort the students in the LinkedList by name
	 * Calls the compareTo method in the Student class
	 *******************************************************/
	public void Sort() {
		if(link.getCount()== 0){
			System.out.println("There's no data to sort");
			return;
		}
		else{
			Node temp = link.getHead();
			link.setCurrentNode(temp);
			int c = link.getCount();
			
			for( int b = 0; b < link.getCount() ; b++){
				int i = 0;
			while(link.getCurrentNode() != null && i <= c ){
			    link.Next();
			    if(temp.getCurrentStudent().compareTo( link.getCurrentNode().getCurrentStudent())==1){
			    	temp = link.getCurrentNode();
			    }
			    
			    Student cp_a = temp.getCurrentStudent();
			    Student cp_b = link.getCurrentNode().getCurrentStudent();
			    
			    temp.setCurrentStudent(cp_b);
			    link.getCurrentNode().setCurrentStudent(cp_a);
			    
			    c--; 
			    link.setCurrentNode(link.getHead());
			    temp = link.getHead();
			}
			}
		}
	}
	public static void main (String [] args){
		Student s = new Student("E", "G0122", 3.99);
		Student v = new Student("D", "G0233", 2.33);
		Student z = new Student("A", "G0125", 3.44);
		Student c = new Student("B", "G0123", 3.44);
		Student o = new Student ("Z", "G012334", 2.33);
		SimpleDatabase m = new SimpleDatabase();
		m.insert(s);
		m.insert(v);
		m.insert(z);
		m.insert(c);
		//m.insert(o);
		System.out.println(m.display());
		m.Sort();
		System.out.println();
		System.out.println(m.display());
		
	}
	

	@Override
	public boolean update(String gNumber, Student student) {

		return false;
	}


	public String display(){
		String d = "";
		Node temp = link.getHead();
		link.setCurrentNode(temp);
		while(link.getCurrentNode() != null){
			String name = link.getCurrentNode().getCurrentStudent().getName();
			String gnumber = link.getCurrentNode().getCurrentStudent().getGNumber();
			String s = ""; 
			String gpa = s+ link.getCurrentNode().getCurrentStudent().getGpa();
			d += name + " " + gnumber + " " + gpa + " " + "\n";
			link.setCurrentNode(link.getCurrentNode().getNext());
		}
		return d;
	}

	@Override
	/***************************************************************
	 * Method to reserve the list of nodes
	 * Students objects are reversed opposite of alphabetical order 
	 ***************************************************************/
	public void reverseList() {
		package1.LinkedList nlist = new package1.LinkedList();
		while(link.getHead() != null){
			nlist.add(link.getTail());
			Node temp = link.getHead();
			while(temp.getNext()!=null && temp.getNext().getNext() != null){
				temp = temp.getNext();
			}
			if(link.getHead() == link.getTail()){
				link.setHead(null);
			}
			link.setTail(temp);
			link.getTail().setNext(null);
		}
		link = nlist; //Point the old empty list to the new reversed one
	}

	@Override
	/******************************************************
	 * Method that removes all duplicates from the list
	 * Only one copy of the duplicates is left in the list
	 *****************************************************/
	public void removeDuplicates(String gNumber) {
		if(link.getCount() == 0){
			System.out.println("There is no data to remove!");
		}
		else{
			Node temp = link.getHead();
			
			
			while(temp.getNext() != null){
				Node before = temp; //The node before the one to be deleted
				Node nextnode = temp.getNext();
				Node next2node = temp.getNext().getNext();
				 
				if(temp == link.getHead() && temp.getCurrentStudent().getGNumber().equals(gNumber)){
                      remove(before, nextnode, next2node);
				}
				if(nextnode.getCurrentStudent().getGNumber().compareTo(gNumber) == 0){
					remove(before, nextnode, next2node); // nextnode will be removed from the list
					temp = temp.getNext();
				}
				else{
					temp = temp.getNext();
				}
			}
		}
	}
	/***************************************************
	 * Method to help with the removal of nodes
	 * @param before the previous node
	 * @param current the one being removed
	 * @param after the node two spots down from current
	 ***************************************************/
	public void remove(Node before, Node remove, Node after){
		if(before == link.getHead()){
			link.setHead(remove);
			before.setNext(null);
		}
		else{
			before.setNext(after);
			remove.setNext(null);
		}
	}


	@Override
	public boolean undo() {
		// To be filled with Recod's code
		return false;
	}

	@Override
	public void loadDB(String fileName) {
		// To be filled with Recod's code
	}

	@Override
	public void saveDB(String fileName) {
		// To be filled with Recod's code
	}

}
